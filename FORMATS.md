# Спецификация форматов файлов

Техническая документация для форматов файлов ресурсов id Mobile RPG.

## Содержание

- [wtexels.bin - Данные текстур](#wtexelsbin---данные-текстур)
- [palettes.bin - Данные палитр](#palettesbin---данные-палитр)
- [Структура JAR](#структура-jar)
- [Примечания по реализации](#примечания-по-реализации)

## wtexels.bin - Данные текстур

### Структура файла

```
Смещение | Размер  | Тип    | Описание
---------|---------|--------|----------------------------------
0x0000   | 4 байта | uint32 | Общий размер данных (little-endian)
0x0004   | N байт  | данные | Данные текстур
```

### Формат текстуры

- **Кодирование:** 4-битный индексированный цвет (упакованный по полубайтам)
- **Размеры:** 64 пикселя × 64 пикселя
- **Байт на текстуру:** 2048 байт (64 × 64 ÷ 2)
- **Палитра по умолчанию:** 16-уровневая градация серого (0-255 с шагом 17)

### Хранение пикселей

Каждый байт содержит 2 пикселя:
```
Байт: [P2][P1]
      7654 3210
      
P1 = байт & 0x0F        (биты 0-3, младший полубайт)
P2 = (байт >> 4) & 0x0F (биты 4-7, старший полубайт)
```

### Порядок хранения

Пиксели хранятся в **порядке по столбцам**:

```
for x = 0 to 63:
    for y = 0 to 63 step 2:
        байт = файл[смещение++]
        пиксель[x, y]   = байт & 0x0F
        пиксель[x, y+1] = (байт >> 4) & 0x0F
```

### Палитра градаций серого по умолчанию

```
Индекс | Значение | RGB
-------|----------|----------
0      | 0        | (0,0,0)
1      | 17       | (17,17,17)
2      | 34       | (34,34,34)
...    | ...      | ...
14     | 238      | (238,238,238)
15     | 255      | (255,255,255)

Формула: RGB = индекс × 17
```

### Несколько текстур

Текстуры хранятся последовательно:

```
Количество текстур = (Размер файла - 4) / 2048

Текстура 0: байты [4...2051]
Текстура 1: байты [2052...4099]
Текстура N: байты [(N×2048)+4 ... ((N+1)×2048)+3]
```

## palettes.bin - Данные палитр

### Структура файла

```
Смещение | Размер  | Тип    | Описание
---------|---------|--------|----------------------------------
0x0000   | 4 байта | uint32 | Общий размер данных (little-endian)
0x0004   | N байт  | данные | Данные палитр
```

### Формат палитры

- **Цветов в палитре:** 16
- **Байт на палитру:** 32 (16 цветов × 2 байта)
- **Формат цвета:** BGR565 (16-бит)

### Формат цвета BGR565

16-битный цвет упакован следующим образом:

```
Бит:    15 14 13 12 11 | 10 09 08 07 06 05 | 04 03 02 01 00
        [   Синий     ] [    Зелёный     ] [   Красный   ]
        5 бит (0-31)    6 бит (0-63)       5 бит (0-31)
```

### Упаковка цвета

```
uint16 цвет = (синий << 11) | (зелёный << 5) | красный

где:
  красный = R >> 3  (преобразование 8-бит в 5-бит)
  зелёный = G >> 2  (преобразование 8-бит в 6-бит)
  синий   = B >> 3  (преобразование 8-бит в 5-бит)
```

### Распаковка цвета

```
R8 = ((цвет & 0x001F) << 3) | ((цвет & 0x001F) >> 2)
G8 = ((цвет & 0x07E0) >> 3) | ((цвет & 0x07E0) >> 9)
B8 = ((цвет & 0xF800) >> 8) | ((цвет & 0xF800) >> 13)

Упрощённо:
  красный5  = цвет & 0x1F
  зелёный6  = (цвет >> 5) & 0x3F
  синий5    = (цвет >> 11) & 0x1F
  
  R = (красный5 << 3) | (красный5 >> 2)
  G = (зелёный6 << 2) | (зелёный6 >> 4)
  B = (синий5 << 3) | (синий5 >> 2)
```

### Хранение палитр

Палитры хранятся последовательно:

```
Количество палитр = (Размер файла - 4) / 32

Палитра 0: байты [4...35]
Палитра 1: байты [36...67]
Палитра N: байты [(N×32)+4 ... ((N+1)×32)+3]

Внутри каждой палитры:
  Цвет 0:  байты [0-1]   (uint16, little-endian)
  Цвет 1:  байты [2-3]
  ...
  Цвет 15: байты [30-31]
```

## Структура JAR

### META-INF/MANIFEST.MF

Определение игры основано на записи MIDlet-1:

```
Manifest-Version: 1.0
MIDlet-1: [Название игры], [Путь к иконке], [Главный класс]
...
```

Примеры:
```
MIDlet-1: Doom RPG, /icon.png, DoomRPG
MIDlet-1: Orcs & Elves, /icon.png, OrcsAndElves
MIDlet-1: Orcs & Elves II, /icon.png, OrcsAndElvesII
```

### Файлы ресурсов

**Doom RPG:**
- `wtexels.bin` - Данные текстур
- `palettes.bin` - Цветовые палитры

**Orcs & Elves:**
- `wtexels0.bin` - Данные текстур (обратите внимание на суффикс '0')
- `palettes.bin` - Цветовые палитры

## Примечания по реализации

### Чтение текстур

```csharp
void ReadTexture(byte[] data, int offset, Bitmap bmp)
{
    for (int x = 0; x < 64; x++)
    {
        for (int y = 0; y < 64; y += 2)
        {
            byte packed = data[offset++];
            
            int index1 = packed & 0x0F;
            int index2 = (packed >> 4) & 0x0F;
            
            bmp.SetPixel(x, y, palette[index1]);
            bmp.SetPixel(x, y + 1, palette[index2]);
        }
    }
}
```

### Запись текстур

```csharp
void WriteTexture(Bitmap bmp, BinaryWriter writer)
{
    for (int x = 0; x < 64; x++)
    {
        for (int y = 0; y < 64; y += 2)
        {
            Color c1 = bmp.GetPixel(x, y);
            Color c2 = bmp.GetPixel(x, y + 1);
            
            int index1 = ColorToIndex(c1);
            int index2 = ColorToIndex(c2);
            
            byte packed = (byte)((index2 << 4) | index1);
            writer.Write(packed);
        }
    }
}
```

### Преобразование в градации серого

```csharp
int ColorToIndex(Color c)
{
    // Преобразование в градации серого с использованием формулы яркости
    int gray = (int)(c.R * 0.299 + c.G * 0.587 + c.B * 0.114);
    
    // Округление до ближайшего индекса палитры
    int index = (gray + 8) / 17;
    
    // Ограничение допустимым диапазоном
    return Math.Min(15, Math.Max(0, index));
}
```

### Чтение палитр

```csharp
Color[] ReadPalette(byte[] data, int offset)
{
    Color[] palette = new Color[16];
    
    for (int i = 0; i < 16; i++)
    {
        ushort bgr565 = BitConverter.ToUInt16(data, offset + i * 2);
        palette[i] = BGR565ToColor(bgr565);
    }
    
    return palette;
}

Color BGR565ToColor(ushort bgr)
{
    int r5 = bgr & 0x1F;
    int g6 = (bgr >> 5) & 0x3F;
    int b5 = (bgr >> 11) & 0x1F;
    
    int r8 = (r5 << 3) | (r5 >> 2);
    int g8 = (g6 << 2) | (g6 >> 4);
    int b8 = (b5 << 3) | (b5 >> 2);
    
    return Color.FromArgb(r8, g8, b8);
}
```

### Запись палитр

```csharp
void WritePalette(Color[] palette, BinaryWriter writer)
{
    for (int i = 0; i < 16; i++)
    {
        ushort bgr565 = ColorToBGR565(palette[i]);
        writer.Write(bgr565);
    }
}

ushort ColorToBGR565(Color c)
{
    int r5 = c.R >> 3;
    int g6 = c.G >> 2;
    int b5 = c.B >> 3;
    
    return (ushort)((b5 << 11) | (g6 << 5) | r5);
}
```

## Валидация

### Валидация текстур

- Размер файла должен быть `4 + (N × 2048)` байт
- Каждая текстура должна быть точно 2048 байт
- Значение заголовка должно совпадать с общим размером данных

### Валидация палитр

- Размер файла должен быть `4 + (N × 32)` байт
- Каждая палитра должна быть точно 32 байта (16 цветов)
- Значение заголовка должно совпадать с общим размером данных

## Порядок байтов (Endianness)

Все многобайтовые значения используют порядок байтов **little-endian**:

```
uint32: [байт0][байт1][байт2][байт3]
        МЗБ                    СЗБ

uint16: [байт0][байт1]
        МЗБ     СЗБ

МЗБ = Младший значащий байт
СЗБ = Старший значащий байт
```

## История версий

- **v0.1** - Первоначальная спецификация формата
  - Поддержка Doom RPG
  - Поддержка извлечения Orcs & Elves

## Справочная информация

- Оригинальная реализация: id Mobile RPG Editor от den_koter
- Целевые платформы: J2ME (Java 2 Micro Edition)
- Цветовое пространство: BGR565 (16-битный цвет)

## Дополнительные примеры

### Пример распаковки текстуры

```csharp
// Чтение одной текстуры из wtexels.bin
byte[] fileData = File.ReadAllBytes("wtexels.bin");
int headerSize = 4;
int textureIndex = 0; // Первая текстура

// Создаём палитру градаций серого
Color[] grayscalePalette = new Color[16];
for (int i = 0; i < 16; i++)
{
    int val = i * 17;
    grayscalePalette[i] = Color.FromArgb(val, val, val);
}

// Создаём изображение
Bitmap bmp = new Bitmap(64, 64);

// Вычисляем смещение для нужной текстуры
int offset = headerSize + (textureIndex * 2048);

// Распаковываем пиксели
for (int x = 0; x < 64; x++)
{
    for (int y = 0; y < 64; y += 2)
    {
        byte packedByte = fileData[offset++];
        
        int p1Index = packedByte & 0x0F;
        int p2Index = (packedByte >> 4) & 0x0F;
        
        bmp.SetPixel(x, y, grayscalePalette[p1Index]);
        bmp.SetPixel(x, y + 1, grayscalePalette[p2Index]);
    }
}

bmp.Save("texture_000.png", ImageFormat.Png);
```

### Пример упаковки текстуры

```csharp
// Упаковка изображения обратно в формат wtexels.bin
Bitmap bmp = new Bitmap("texture_000.png");

using (FileStream fs = new FileStream("wtexels_new.bin", FileMode.Create))
using (BinaryWriter writer = new BinaryWriter(fs))
{
    // Записываем заголовок (размер данных)
    writer.Write((uint)2048);
    
    // Упаковываем пиксели
    for (int x = 0; x < 64; x++)
    {
        for (int y = 0; y < 64; y += 2)
        {
            Color c1 = bmp.GetPixel(x, y);
            Color c2 = bmp.GetPixel(x, y + 1);
            
            // Преобразуем в градации серого
            int gray1 = (int)(c1.R * 0.299 + c1.G * 0.587 + c1.B * 0.114);
            int gray2 = (int)(c2.R * 0.299 + c2.G * 0.587 + c2.B * 0.114);
            
            // Преобразуем в индексы палитры
            int index1 = Math.Min(15, Math.Max(0, (gray1 + 8) / 17));
            int index2 = Math.Min(15, Math.Max(0, (gray2 + 8) / 17));
            
            // Упаковываем два пикселя в один байт
            byte packedByte = (byte)((index2 << 4) | index1);
            writer.Write(packedByte);
        }
    }
}
```

### Пример работы с палитрой

```csharp
// Чтение палитры
byte[] paletteData = File.ReadAllBytes("palettes.bin");
int headerSize = 4;
int paletteIndex = 0;

Color[] palette = new Color[16];
int offset = headerSize + (paletteIndex * 32);

for (int i = 0; i < 16; i++)
{
    ushort bgr565 = BitConverter.ToUInt16(paletteData, offset);
    offset += 2;
    
    // Распаковываем компоненты цвета
    int r5 = bgr565 & 0x1F;
    int g6 = (bgr565 >> 5) & 0x3F;
    int b5 = (bgr565 >> 11) & 0x1F;
    
    // Расширяем до 8-бит
    int r8 = (r5 << 3) | (r5 >> 2);
    int g8 = (g6 << 2) | (g6 >> 4);
    int b8 = (b5 << 3) | (b5 >> 2);
    
    palette[i] = Color.FromArgb(r8, g8, b8);
}

// Создаём визуализацию палитры (полоска 256x16 пикселей)
Bitmap paletteBmp = new Bitmap(256, 16);
using (Graphics g = Graphics.FromImage(paletteBmp))
{
    for (int i = 0; i < 16; i++)
    {
        using (SolidBrush brush = new SolidBrush(palette[i]))
        {
            g.FillRectangle(brush, i * 16, 0, 16, 16);
        }
    }
}
paletteBmp.Save("palette_000.png", ImageFormat.Png);
```

## Часто задаваемые вопросы

### Почему используется BGR вместо RGB?

Формат BGR565 был распространён на мобильных платформах J2ME из-за особенностей аппаратного обеспечения некоторых телефонов той эпохи.

### Почему текстуры 64×64?

Это был стандартный размер для текстур в мобильных 3D-играх того времени, обеспечивающий баланс между качеством и производительностью на ограниченном оборудовании.

### Можно ли использовать полноцветные текстуры?

Формат wtexels.bin поддерживает только 4-битные индексированные текстуры (16 цветов). Для полного цвета используйте палитры.

### Как работает упаковка двух пикселей в один байт?

Младшие 4 бита (0-3) хранят индекс первого пикселя, старшие 4 бита (4-7) хранят индекс второго пикселя. Это позволяет сжать данные в 2 раза.